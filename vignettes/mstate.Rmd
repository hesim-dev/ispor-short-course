---
title: Semi-Markov Multi-state Models
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: yes
    toc_depth: 2
    number_sections: TRUE
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Semi-Markov Multi-state Models}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Overview
Our sick-sicker Markov cohort was time homogeneous, meaning that transition probabilities were constant over time. Although the model could be extended to be time-inhomogeneous so that transition probabilities depend on time since the *start of the model*, transition probabilities cannot depend on prior history. The partitioned survival model are similarly limited in that it made the somewhat implausible assumption that transition probabilities between the healthy and death and sick and death states are equal. An alternative approach is to use a *semi-Markov* model which relaxes these assumptions by allowing transition probabilities to depend on *time since entering a new state*.

If individual patient data is available, semi-Markov models can be parameterized using multi-state models, which are generalizations of survival models to more than 2 states that estimate hazard functions for each possible transition. This is ideal because it ensures that the simulation model is completely integrated with an underlying statistical model. To illustrate, we will continue the 3-state example from the partitioned survival model (PSM) but explicitly model the hazards of each transition: (1) healthy to sick, (2) healthy to dead, and (3) sick to dead. (Note that we could also fit a reversible model where there is also a transition from sick to healhy but we will not do that here to maintain consistency with the PSM.) 

```{r, out.width = "600px", echo = FALSE}
knitr::include_graphics("illness-death.png")
```

In multi-state modeling, a semi-Markov model is referred to as a "clock reset" model since time resets to 0 each time a patient enters a new state. State occupancy probabilities in clock-reset models can only be simulated in a general fashion using individual-patient simulation. While individual-level simulations can be computationally intensive, they run very quickly in the `hesim` package because they are implemented fully in `C++` under the hood. `hesim` also simulates patients trajectories in continuous-time, which is faster than a discrete time approach. We refer to these types of models as individual-level continuous-time state transition models (iCTSTMs). You can learn more about them in the [`hesim` package vignettes](https://hesim-dev.github.io/hesim/articles/mstate.html).


# Model setup
```{r}
library("hesim")
library("data.table")
library("ggplot2")

set.seed(101)
```

```{r}
tmat <- rbind(
  c(NA, 1, 2),
  c(NA, NA, 3),
  c(NA, NA, NA)
)
colnames(tmat) <- rownames(tmat) <- c("Healthy", "Sick", "Dead")
print(tmat)
```

```{r}
n_patients <- 1000
patients <- data.table(
  patient_id = 1:n_patients,
  age = rnorm(n_patients, mean = 45, sd = 7),
  female = rbinom(n_patients, size = 1, prob = .51)
)

states <- data.table(
  state_id = c(1, 2),
  state_name = c("Healthy", "Sick") # Non-death health states
)

strategies <- data.frame(
  strategy_id = 1:2,
  strategy_name = c("SOC", "New")
)

hesim_dat <- hesim_data(
  strategies = strategies,
  patients = patients,
  states = states
)
print(hesim_dat)
```

# Parameter estimation
## Multi-state model

```{r}
data <- rcea::sim_mstate_data(n = 2000)
```

```{r}
library("flexsurv")
n_trans <- max(tmat, na.rm = TRUE) # Number of transitions
wei_fits <- vector(length = n_trans, mode = "list")
for (i in 1:length(wei_fits)){
  wei_fits[[i]] <- flexsurv::flexsurvreg(
    Surv(time, status) ~ strategy_name + female,
    data = data,
    subset = (transition_id == i) ,
    dist = "weibull")
}
wei_fits <- flexsurvreg_list(wei_fits)
```

## Utility and costs
```{r}
utility_tbl <- stateval_tbl(
  data.table(state_id = states$state_id,
             mean = c(H = 1, S = .625),
             se = c(0, .05)
            ),
  dist = "beta",
  hesim_data = hesim_dat)
```

```{r}
drugcost_tbl <- stateval_tbl(
  data.table(strategy_id = strategies$strategy_id,
            est = c(2000, 12000)
            ),
  dist = "fixed",
  hesim_data = hesim_dat)

medcost_tbl <- stateval_tbl(
  data.table(state_id = states$state_id,
             mean = c(H = 2000, S = 9500),
             se = c(H = 2000, S = 9500)
             ),
  dist = "gamma",
  hesim_data = hesim_dat)
```

# Simulation
## Constructing the economic model

```{r}
n_samples <- 500
```

### Disease model

```{r}
transmod_data <- expand(hesim_dat,
                        by = c("strategies", "patients"))
head(transmod_data)
```
```{r}
transmod <- create_IndivCtstmTrans(wei_fits, transmod_data,
                                   trans_mat = tmat, n = n_samples,
                                   clock = "reset",
                                   start_age = patients$age)
```

### Utility and cost models

```{r}
# Utility
utilitymod <- create_StateVals(utility_tbl, n = n_samples)

# Costs
drugcostmod <- create_StateVals(drugcost_tbl, n = n_samples)
medcostmod <- create_StateVals(medcost_tbl, n = n_samples)
costmods <- list(Drug = drugcostmod,
                 Medical = medcostmod)
```

### Combining the disease progression, cost, and utility models

```{r}
econmod <- IndivCtstm$new(trans_model = transmod,
                          utility_model = utilitymod,
                          cost_models = costmods)
```

## Simulating outcomes

### Disease progression

```{r}
econmod$sim_disease(max_age = 100)
head(econmod$disprog_)
```
```{r}
econmod$sim_stateprobs(t = seq(0, 20 , 1/12))
```

```{r, echo = FALSE, fig.width = 7, fig.height = 4}
# Short funtion add create state name variable to data.tabale
add_state_name <- function(x){
  x[, state_name := factor(state_id,
                           levels = 1:nrow(tmat),
                           labels = colnames(tmat))]
}

# Short function to create state probability "dataset" for plotting
summarize_stprobs <- function(stateprobs){
  x <- stateprobs[, .(prob_mean = mean(prob)),
                  by = c("strategy_id", "state_id", "t")]
  add_state_name(x)
}

# Plot of state probabilities
stprobs <- summarize_stprobs(econmod$stateprobs_)
ggplot(stprobs, aes(x = t, y = prob_mean, col = factor(strategy_id))) +
  geom_line() + facet_wrap(~state_name) +
  xlab("Years") + ylab("Probability in health state") +
  scale_color_discrete(name = "Strategy") +
  theme(legend.position = "bottom") +
  theme_bw()
```

### QALYs

```{r}
econmod$sim_qalys(dr = c(0,.03))
head(econmod$qalys_)
```

### Costs

```{r}
econmod$sim_costs(dr = 0.03)
head(econmod$costs_)
```

# Cost-effectiveness analysis

```{r}
ce_sim <- econmod$summarize()
icea_pw_out <- icea_pw(ce_sim, comparator = 1, 
                       dr_qalys = .03, dr_costs = .03,
                       k = seq(0, 25000, 500))
```

```{r icer}
icer_tbl(icea_pw_out, colnames = strategies$strategy_name) 
```

