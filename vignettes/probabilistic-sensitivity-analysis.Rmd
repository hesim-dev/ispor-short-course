---
title: Incorporating Probabilistic Sensitivity Analysis  
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: yes
    toc_depth: 2
    number_sections: TRUE
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{Incorporating Probabilistic Sensitivity Analysis}
  %\VignetteEngine{fknitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Overview
Probabilistic sensitivity analysis (PSA) is used to quantify the impact of parameter uncertainty on the uncertainty of model outputs. PSA is typically performed via a simulate approach whereby the model parameters are randomly sampled from suitable probability distributions and the entire model is simulated for each random draw of the parameters. 

In this example, we extend the deterministic [simple Markov cohort model](simple-markov-cohort-model.html) to incorporate PSA. We will continue to rely primarily on Base `R` but will use the `hesim` package to help make the code more readable.

```{r, message = FALSE, warning=FALSE, results='hide'}
library("learnCEA")
library("hesim")
library("magrittr")
```

# Model parameters
## Transition probabilities for SOC
The probability distribution used for transition probabilities will depend on the underlying data. In this case, we assume that summary level data is available on transitions from the Healthy state (n = 900), Sick state (n = 900), and Sicker state (n = 800). The transitions from each state to the othe 4 states can be modeled using a Dirichlet distribution (see Appendix).

```{r, message=FALSE}
transitions_soc <- matrix(
  c(848, 150, 0,   2,
    450, 355, 95,  5,
    0,   0,   784, 16,
    0,   0,   0,   23),
  nrow = 4, byrow = TRUE)
state_names <- c("H", "S1", "S2", "D")
colnames(transitions_soc) <- rownames(transitions_soc) <- tolower(state_names)
```

## Relative risk
We estimate treatment effects in terms of the log relative risk since it is approximately normally distributed; that is, the relative risk follows a lognormal distribution. The mean is given by the log of the point estimate of the relatie risk, or $log(0.8)$. 

Since academic studies often report 95\% confidence intervals for a parameter, but not its standard error, we will assume that is the case. Specifically, let the lower bound be $log(0.71)$ and the upper bound be $log(0.91)$. The standard error is then given by $(log(0.91) - log(0.71))/(2z)$ where $z = \Phi^{-1}(0.975)\approx 1.96$. See the Appendix for details.

## Costs
### Medical costs
Medical costs are of often assumed to follow a gamma distribution because it can be used to model right skewed distributions. The gamma distribtution is defined in terms of a shape and scale (or rate) parameter. However, these parameters can be derived form the mean and standard deviation of a distribution using the [method of moments](https://hesim-dev.github.io/hesim/reference/mom_gamma.html). Mean costs follow those in the deterministic example (H = $2,000, S1 = $4,000, and S2 = $2,000). The standard deviation in each state is assume to be equal to the mean. 

### Treatment costs
Treatment costs are fixed and equal to the costs in the deterministic example.

## Utility
The utility associated with each state is assumed to follow a beta distribution, which is bounded between 0 and 1. The beta distribution is defined in terms of 2 shape parameters, but like the gamma distribution , these can be derived using the [method of moments](https://hesim-dev.github.io/hesim/reference/mom_beta.html). We assume that the mean (standard error) of utility is estimated to be $1 (0.0)$, $0.75 (0,03)$, $0.5 (0.05)$, and $0 (0.0)$ in state H, S1, S2, and D, respectively. 

## Combining the parameters
All model parameters (transition probabilities, relative risk, costs, and utility) can be stored in a list for use in the simulation.

```{r}
params <- list(
  alpha_soc = transitions_soc,
  lrr_mean = log(.8),
  lrr_lower = log(.71),
  lrr_upper = log(.9),
  c_medical = c(H = 2000, S1 = 4000, S2 = 15000, D = 0),
  c_soc = 2000,
  c_new = 12000,
  u = c(H = 1, S1 = .075, S2 = 0.5, D = 0)
)
```

# Simulation
## Sampling the parameters
```{r}
rng_def <- define_rng({
  lrr_se <- (lrr_upper - lrr_lower)/(2 * qnorm(.975)) # Local object 
                                                      # not returned
  list( # Parameters to return
    p_soc = dirichlet_rng(alpha_soc),
    rr_new = lognormal_rng(lrr_mean, lrr_se),
    c_medical = gamma_rng(mean = c_medical, sd = c_medical),
    c_soc = c_soc,
    c_new = c_new,
    u = fixed(u)
  )
}, n = 1000)
params_rng <- eval_rng(rng_def, params = params)
attr(params_rng, "n") <- rng_def$n
```

## Simulating the Markov model
```{r}
data <- data.frame(
  strategy = c("New", "SOC")
)
```

```{r}
sim_stateprobs <- function(p0, rr, strategy, n_cycles){
  rr <- ifelse(strategy == "New", rr, 1)
  p <- tpmatrix(
    C,       p0$h_s1 * rr,  p0$h_s2 * rr,  p0$h_d * rr,
    p0$s1_h, C,             p0$s1_s2 * rr, p0$s1_d * rr,
    p0$s2_h, p0$s2_s1,      C,             p0$s2_d * rr,
    0,       0,             0,             1
  )
  x <- sim_markov_chain(x0 = c(1, 0, 0, 0),
                        p = matrix(as.matrix(p), ncol = 4, byrow = TRUE),
                        n_cycles = n_cycles)
  return(x)
}
```

```{r}
# QALYs
compute_qalys <- function(x, utility, dr = .03){
  n_cycles <- nrow(x) - 1
  pv(x %*% utility, dr, 0:n_cycles)
}

# Costs
compute_costs <- function(x, costs_medical, costs_treat, dr = .03){
  n_cycles <- nrow(x) - 1
  costs_treat <- c(rep(costs_treat, 3), 0)
  costs <- cbind(
    pv(x %*% costs_medical, dr, 0:n_cycles),
    pv(x %*% costs_treat, dr, 0:n_cycles)
  )
  colnames(costs) <- c("dcost_med", "dcost_treat")
  return(costs)
}
```

```{r}
sim_model <- function(params_rng, data, n_cycles = 85, 
                      dr_qalys = .03, dr_costs = .03){
  # Initialize array of matrices
  n_samples <- attr(params_rng, "n")
  n_strategies <- nrow(data)
  out <- array(NA, dim = c(n_cycles + 1, 7, n_samples * n_strategies))
  dimnames(out) <- list(NULL, 
                        c("H", "S1", "S2", "D",
                          "dqalys", "dcosts_med", "dcosts_treat"), 
                        NULL)
  
  # Run the simulation
  i <- 1
  for (s in 1:n_samples){ # Start PSA loop
    for (k in 1:n_strategies) { # Start treatment strategy loop
      x <- sim_stateprobs(p0 = params_rng$p_soc[s, ],
                          rr = params_rng$rr_new[s],
                          strategy = data$strategy[k],
                          n_cycles = n_cycles)
     dqalys <- compute_qalys(x, utility = unlist(params_rng$u[s]), 
                             dr = dr_qalys)
     dcosts <- compute_costs(x, 
                             costs_medical = unlist(params_rng$c_medical[s]), 
                             costs_treat = ifelse(data$strategy[k] == "SOC", 
                                                  params_rng$c_soc,
                                                  params_rng$c_new),
                             dr = dr_costs)
      out[, , i] <- cbind(x, dqalys, dcosts)
      i <- i + 1
    } # End treatment strategy loop
  } # End PSA loop
  return(out)
}
```

```{r, cache = TRUE}
sim_out <- sim_model(params_rng, data = data)
head(sim_out[, , 1])
```

# Appendix
## Dirichlet distribution
The multinomial distribution is a discrete probability distribution for the number of successes for each of k mutually exclusive categories in n trials. The probabilities of the categories are given by $\pi_1,\ldots, \pi_k$ with $\sum_{j=1}^k \pi_j=1$ and each $\pi_j$ defined on $[0,1]$. The Dirichlet distribution is parameterized by the concentration parameters $\alpha_1,\ldots, \alpha_k$ with $\alpha_j > 0$. Letting $x_1,\ldots, x_k$ denote the number of successes in each category, the prior distribution and likelihood are,

$$
\begin{aligned}
p(\pi_1,\ldots,\pi_k |\alpha_1,\ldots, \alpha_k) = \text{Dirichlet}(\alpha_1,\ldots,\alpha_k) \\
p(x_1,\ldots,x_k | \pi_1,\ldots,\pi_k) = \text{Multin}(n, \pi_1,\ldots,\pi_k).
\end{aligned}
$$

## Confidence intervals and standard errors